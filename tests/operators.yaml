
- test: Binary
  source: |
    println(10+11);
    println("New " + "text");
    println([1, 2] + [3, 4]);
    println(7*8);
    println(12/3);
    println(12 % 3.3);
  out: |
    21
    New text
    [1, 2, 3, 4]
    56
    4
    2.1

- test: Assignment operator
  source: |
    let a=10;
    let txt="New";
    let arr = [1, 2];
    &a += 11; println(a);
    &txt += " text"; println(txt);
    &arr += [3, 4]; println(arr);
    &a *= 9; println(a);
    &a /= 3; println(a);
    &a %= 5; println(a);
  out: |
    21
    New text
    [1, 2, 3, 4]
    189
    63
    3

- test: Assignment cont operator
  source: |
    let a=[1,2,3];
    let b=1;
    &a[0] += 11;
    &a[b] *= 2;
    &a[a[2]-1] = 9;
    println(a);
  out: |
    [12, 4, 9]

- test: Invalid assignment (1)
  source: |
    let a = 10;
    &!=10;
  out:
    regex: "expected identifier, but got"
  exit_code: 1

- test: Invalid assignment (2)
  source: |
    let a = 10;
    &!=10;
  out:
    regex: "expected identifier, but got"
  exit_code: 1

- test: Invalid assignment (3)
  source: |
    let a = 10;
    &a&=10;
  out:
    regex: "unexpected token"
  exit_code: 1

- test: Invalid assignment (3)
  source: |
    let a = [1,2];
    &a.5=10;
  out:
    regex: "expected identifier, but got"
  exit_code: 1

- test: Unary
  source: |
    let a = false;
    println(a);
    &a = !a;
    println(a);
    println(-10);
    println(--10);
  out: |
    false
    true
    -10
    10

- test: OR simple
  source:
    fn update(inout val) {
      let n=0;
      while n < len(val) {
        if (val[n] == false) { &val[n] = true; return false; }
        &val[n] = false; &n += 1; }
      return true; }

    fn test(a) {
      return (a[0] || a[1]); }

    println("a[0] || a[1]");
    let a = [false, false];
    loop {
      if test(a) { println(a); }
      if (update(&a)) { break; } }
  out: |
    a[0] || a[1]
    [true, false]
    [false, true]
    [true, true]

- test: OR multiple
  source:
    fn update(inout val) {
      let n=0;
      while n < len(val) {
        if (val[n] == false) { &val[n] = true; return false; }
        &val[n] = false; &n += 1; }
      return true; }

    fn test(a) {
      return (a[0] || a[1] || a[2]); }

    println("a[0] || a[1] || a[2]");
    let a = [false, false, false];
    loop {
      if test(a) { println(a); }
      if (update(&a)) { break; } }
  out: |
    a[0] || a[1] || a[2]
    [true, false, false]
    [false, true, false]
    [true, true, false]
    [false, false, true]
    [true, false, true]
    [false, true, true]
    [true, true, true]

- test: AND simple
  source:
    fn update(inout val) {
      let n=0;
      while n < len(val) {
        if (val[n] == false) { &val[n] = true; return false; }
        &val[n] = false; &n += 1; }
      return true; }

    fn test(a) {
      return (a[0] && a[1]); }

    println("a[0] && a[1]");
    let a = [false, false];
    loop {
      if test(a) { println(a); }
      if (update(&a)) { break; } }
  out: |
    a[0] && a[1]
    [true, true]

- test: AND multiple
  source:
    fn update(inout val) {
      let n=0;
      while n < len(val) {
        if (val[n] == false) { &val[n] = true; return false; }
        &val[n] = false; &n += 1; }
      return true; }

    fn test(a) {
      return (a[0] && a[1] && a[2]); }

    println("a[0] && a[1] && a[2]");
    let a = [false, false, false];
    loop {
      if test(a) { println(a); }
      if (update(&a)) { break; } }
  out: |
    a[0] && a[1] && a[2]
    [true, true, true]

- test: mix OR and AND
  source:
    fn update(inout val) {
      let n=0;
      while n < len(val) {
        if (val[n] == false) { &val[n] = true; return false; }
        &val[n] = false; &n += 1; }
      return true; }

    fn test(a) {
      return ((a[0] || a[1]) && (a[2] || a[3])); }

    println("(a[0] || a[1]) && (a[2] || a[3])");
    let a = [false, false, false, false];
    loop {
      if test(a) { println(a); }
      if (update(&a)) { break; } }
  out: |
    (a[0] || a[1]) && (a[2] || a[3])
    [true, false, true, false]
    [false, true, true, false]
    [true, true, true, false]
    [true, false, false, true]
    [false, true, false, true]
    [true, true, false, true]
    [true, false, true, true]
    [false, true, true, true]
    [true, true, true, true]

- test: mix OR and AND (2)
  source:
    fn update(inout val) {
      let n=0;
      while n < len(val) {
        if (val[n] == false) { &val[n] = true; return false; }
        &val[n] = false; &n += 1; }
      return true; }

    fn test(a) {
      return ((a[0] && a[1]) || (a[2] && a[3])); }

    println("(a[0] && a[1]) || (a[2] && a[3])");
    let a = [false, false, false, false];
    loop {
      if test(a) { println(a); }
      if (update(&a)) { break; } }
  out: |
    (a[0] && a[1]) || (a[2] && a[3])
    [true, true, false, false]
    [true, true, true, false]
    [true, true, false, true]
    [false, false, true, true]
    [true, false, true, true]
    [false, true, true, true]
    [true, true, true, true]

- test: mix OR and AND and NOT
  source:
    fn update(inout val) {
      let n=0;
      while n < len(val) {
        if (val[n] == false) { &val[n] = true; return false; }
        &val[n] = false; &n += 1; }
      return true; }

    fn test(a) {
      return ((a[0] && (a[1] || a[2])) && (!a[3] || a[4])); }

    println("(a[0] && (a[1] || a[2])) && (!a[3] || a[4])");
    let a = [false, false, false, false, false];
    loop {
      if test(a) { println(a); }
      if (update(&a)) { break; } }
  out: |
    (a[0] && (a[1] || a[2])) && (!a[3] || a[4])
    [true, true, false, false, false]
    [true, false, true, false, false]
    [true, true, true, false, false]
    [true, true, false, false, true]
    [true, false, true, false, true]
    [true, true, true, false, true]
    [true, true, false, true, true]
    [true, false, true, true, true]
    [true, true, true, true, true]

- test: mix OR and AND and NOT (inverse)
  source:
    fn update(inout val) {
      let n=0;
      while n < len(val) {
        if (val[n] == false) { &val[n] = true; return false; }
        &val[n] = false; &n += 1; }
      return true; }

    fn test(a) {
      return (a[0] || (a[1] && a[2])) || (a[3] && !a[4]); }

    println("(a[0] || (a[1] && a[2])) || (a[3] && !a[4])");
    let a = [false, false, false, false, false];
    loop {
      if test(a) { println(a); }
      if (update(&a)) { break; } }
  out: |
    (a[0] || (a[1] && a[2])) || (a[3] && !a[4])
    [true, false, false, false, false]
    [true, true, false, false, false]
    [true, false, true, false, false]
    [false, true, true, false, false]
    [true, true, true, false, false]
    [false, false, false, true, false]
    [true, false, false, true, false]
    [false, true, false, true, false]
    [true, true, false, true, false]
    [false, false, true, true, false]
    [true, false, true, true, false]
    [false, true, true, true, false]
    [true, true, true, true, false]
    [true, false, false, false, true]
    [true, true, false, false, true]
    [true, false, true, false, true]
    [false, true, true, false, true]
    [true, true, true, false, true]
    [true, false, false, true, true]
    [true, true, false, true, true]
    [true, false, true, true, true]
    [false, true, true, true, true]
    [true, true, true, true, true]
